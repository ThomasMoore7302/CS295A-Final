module Dijkstra where

open import Basics002

{- ****THE CODE***


G is the input graph, s is the source vertex, `(uv) is the length of an edge from u to v, and V is the set of
vertices.

Dijkstra(G, s)
  for all u âˆˆ V \ {s}, d(u) = âˆ
  d(s) = 0
  R = {}
  while R â‰  V
    pick u âˆ‰ R with smallest d(u)
    R = R âˆª {u}
    for all vertices v adjacent to u
      if d(v) > d(u) + `(u, v)
        d(v) = d(u) + `(u, v)
-}

postulate
  -- implement later
  _â‰¡?áµ›_ : âˆ€ {n : â„•} â†’ vec[ n ] ğ”¹ â†’ vec[ n ] ğ”¹ â†’ â‰¡!
  _â‰¡?â±_ : âˆ€ {n : â„•} â†’ idx n â†’ idx n â†’ â‰¡!
  _<?á´®_ : â„• â†’ â„• â†’ ğ”¹
  -- never implemented
  âˆ : â„•


-- picking the smallest weight to descide on where to move next and how weights should be changed.
pick-smallest : âˆ€ {n} â†’ idx n â†’ vec[ n ] â„• â†’ vec[ n ] ğ”¹ â†’ idx n
pick-smallest {n} s d R =
  let stateâ‚€ : idx n
      stateâ‚€ = s
      s-finalâ‚ = vlfold d stateâ‚€ s-final-body
      -- if i has been seen before, do nothing
      -- if i has not been seen, and BOTH d(stateáµ¢) < d(i) AND we have not seen stateáµ¢ before, then do nothing
      s-final = vlfold d stateâ‚€ Î» i d[i] stateáµ¢ â†’
        CASE R #[ i ] â©” ((d #[ stateáµ¢ ] <?á´® d[i]) â©“ R #[ stateáµ¢ ]) OF Î» where
          I â†’ stateáµ¢
          O â†’ i
  in s-final
    where
      s-final-body : idx n â†’ â„• â†’ idx n â†’ idx n
      s-final-body i d[i] stateáµ¢ with R #[ i ] â©” ((d #[ stateáµ¢ ] <?á´® d[i]) â©“ R #[ stateáµ¢ ])
      â€¦ | I = stateáµ¢
      â€¦ | O = i

dijkstra-inner-loop : âˆ€ {n : â„•} â†’ graph[ n ] â†’ idx n â†’ idx n â†’ vec[ n ] â„• â†’ vec[ n ] â„•
dijkstra-inner-loop g u v d with g #[ u ] #[ v ]
dijkstra-inner-loop g u v [] | O = []
dijkstra-inner-loop g u v (x âˆ· d) | O = x âˆ· d -- not adjacent
â€¦ | I = d  -- is adjacent

--                                                                               
--                                       input        input        output       outrut
--                          whole graph  distances    seen set     distances    seen set
--                          âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„   âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„   âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„  âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„   âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„âŒ„
dijkstra-loop : âˆ€ {n : â„•} â†’ graph[ n ] â†’ vec[ n ] â„• â†’ vec[ n ] ğ”¹ â†’ vec[ n ] â„• âˆ§ vec[ n ] ğ”¹
dijkstra-loop g d R with R â‰¡?áµ› const[vec]< _ > I
â€¦ | [â‰¡] = âŸ¨ d , R âŸ© -- done
â€¦ | [â‰¢] = âŸ¨ d , R âŸ© -- not done

-- this is what Dikjstra above in pseudocode corresponds to
dijkstra-vertex : âˆ€ {n : â„•} â†’ graph[ n ] â†’ idx n â†’ vec[ n ] â„•
dijkstra-vertex {n} g s =
  -- initial output distances
  let dâ‚€ : vec[ n ] â„•
      dâ‚€ = (const[vec]< n > âˆ) #[ s â†¦ 0 ]
      -- dâ€² : vec[ n ] â„•
      -- Râ€² : vec[ n ] ğ”¹
      âŸ¨ dâ€² , Râ€² âŸ© = dijkstra-loop g dâ‚€ (const[vec]< n > O)
  in dâ€²

dijkstra : âˆ€ {n : â„•} â†’ graph[ n ] â†’ matrix[ n , n ] â„•
dijkstra [] = []
dijkstra (x âˆ· g) = dijkstra-vertex (x âˆ· g) Z âˆ· {!dijkstra-vertex (x âˆ· g)  !} 



 

{- ***THE PROOF***



Let d(v) be the label found by the algorithm and let Î´(v) be the shortest path distance from s-to-v. We
want to show that d(v) = Î´(v) for every vertex v at the end of the algorithm, showing that the algorithm
correctly computes the distances. We prove this by induction on |R| via the following lemma:

                    ****Lemma: For each x âˆˆ R, d(x) = Î´(x).*****


Proof by Induction: Base case (|R| = 1): Since R only grows in size, the only time |R| = 1 is when R = {s} and d(s) = 0 = Î´(s), which is correct.


Inductive hypothesis: Let u be the last vertex added to R. Let R0 = Râˆª {u}. Our I.H. is: for each x âˆˆ Râ€², d(x) = Î´(x).


Using the I.H.: By the inductive hypothesis, for every vertex in Râ€² that isnâ€™t u, we have the correct distance label. We need only show that d(u) = Î´(u) to complete the proof.


Suppose for a contradiction that the shortest path from s-to-u is Q and has length
                                  
                                 ğ“(Q) < d(u).


Q starts in Râ€² and at some leaves Râ€² (to get to u which is not in Râ€²). Let xy be the first edge along Q that leaves Râ€². Let Qx be the s-to-x subpath of Q. Clearly:

                              ğ“(Qx) + ğ“(xy) â‰¤ ğ“(Q).


Since d(x) is the length of the shortest s-to-x path by the I.H., d(x) â‰¤ `(Qx), giving us

                              d(x) + `(xy) â‰¤ `(Qx).


Since y is adjacent to x, d(y) must have been updated by the algorithm, so

                               d(y) â‰¤ d(x) + `(xy).


Finally, since u was picked by the algorithm, u must have the smallest distance label:

                                     d(u) â‰¤ d(y).

Combining these inequalities in reverse order gives us the contradiction that d(x) < d(x). Therefore, no suCh shorter path Q must exist and so d(u) = Î´(u).


This lemma shows the algorithm is correct by â€œapplyingâ€ the lemma for R = V .
-}


---
-- notes from 11-22-19

_ :
  let xs = 10 âˆ· 11 âˆ· 12 âˆ· []
      ys = 20 âˆ· 21 âˆ· 22 âˆ· []
  in vlfold xs âŸ¨ O , 100 âŸ© (Î» where i x âŸ¨ b , n âŸ© â†’ âŸ¨ not b , n + x + ys #[ i ] âŸ©)
  â‰¡
  âŸ¨ I , 196 âŸ©
_ = â†¯

-- do something for all indices N
-- e.g., for each index, look up a value at that index and compute the
-- sum
-- let xs = [10,11,12]
-- n = 0
-- for i âˆˆ indices(xs):
--   n = n + xs[i] 
_ :
  let xs : vec[ 3 ] â„•
      xs = 10 âˆ· 11 âˆ· 12 âˆ· []
      is : vec[ 3 ] ğŸ™
      -- is = â€¢ âˆ· â€¢ âˆ· â€¢ âˆ· []
      is = const[vec]< 3 > â€¢
  in vlfold is 0 (Î» i _ n â†’ n + xs #[ i ]) â‰¡ 33
_ = â†¯

-- EXAMPLE OF NESTED CASE STATEMENT (like with, but can be nested)
  -- vlfold (const[vec]< n > â€¢) stateâ‚€ Î» u _ stateáµ¢ {- <- loop-intermediate state -} â†’
  --   CASE (s â‰¡?â± u) OF Î» where
  --     [â‰¡] â†’ stateáµ¢
  --     -- you have some u â‰  s, run dijkstra-loop on u
  --     [â‰¢] â†’ {!dikjstra-loop g u stateáµ¢!}